<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_65) on Mon Aug 24 15:11:39 BST 2015 -->
<TITLE>
TreeNode
</TITLE>

<META NAME="date" CONTENT="2015-08-24">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="TreeNode";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/TreeNode.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeBranch.html" title="class in uk.ac.qmul.sbcs.evolution.convergence"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/VariantSitesUnavailableException.html" title="class in uk.ac.qmul.sbcs.evolution.convergence"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html?uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="TreeNode.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
uk.ac.qmul.sbcs.evolution.convergence</FONT>
<BR>
Class TreeNode</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../../resources/inherit.gif" ALT="extended by "><B>uk.ac.qmul.sbcs.evolution.convergence.TreeNode</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>TreeNode</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
A utility class for operations on phylogenetic trees.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD><a href="mailto:joe@kitson-consulting.co.uk">Joe Parker, Kitson Consulting / Queen Mary University of London</a></DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashSet&lt;java.lang.String&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#states">states</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#TreeNode(java.lang.String, int)">TreeNode</A></B>(java.lang.String&nbsp;tree,
         int&nbsp;startAt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor for node</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashSet&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#areTipsPresent(java.util.HashSet)">areTipsPresent</A></B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;echoMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Which of the tips in the supplied list are below this node?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#containsMonophyleticClade(java.util.HashSet)">containsMonophyleticClade</A></B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;someTaxa)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeBranch.html" title="class in uk.ac.qmul.sbcs.evolution.convergence">TreeBranch</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getBranches()">getBranches</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return all the branches in the tree by postorder traversal</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getBranchesAsCoOrdinates(int, int, int, int)">getBranchesAsCoOrdinates</A></B>(int&nbsp;startX,
                         int&nbsp;startY,
                         int&nbsp;branchIncrementX,
                         int&nbsp;branchIncrementY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a list of relative X,Y positions for line segments representing branches, to be rendered with a Graphics2D.drawLine(x1,y1,x2,y2) call or similar.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getBranchesAsCoordinatesFromTips(int, int)">getBranchesAsCoordinatesFromTips</A></B>(int&nbsp;depth,
                                 int&nbsp;tipNumber)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getBranchNumberingIDContainingTaxa(java.util.HashSet)">getBranchNumberingIDContainingTaxa</A></B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;taxaContained)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A method to retrieve the number (node ID, as set in <CODE>TreeNode#setNodeNumbers()</CODE> method) of the lowest node containing all taxa present in taxaContained, a <CODE>HashSet</CODE> of <CODE>String</CODE>s representing taxa.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getContent()">getContent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getEndPos()">getEndPos</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the position the last node constructor left at</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashSet&lt;java.lang.String&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getFitchStates(java.util.HashMap)">getFitchStates</A></B>(java.util.HashMap&lt;java.lang.String,java.util.HashSet&lt;java.lang.String&gt;[]&gt;&nbsp;inputStates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html" title="class in uk.ac.qmul.sbcs.evolution.convergence">TreeNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getNodeByNumberingID(int)">getNodeByNumberingID</A></B>(int&nbsp;nodeID)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method to return the node corresponding to a particular node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getNodeNumberingIDContainingTaxa(java.util.HashSet)">getNodeNumberingIDContainingTaxa</A></B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;taxaContained)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A method to retrieve the number (node ID, as set in <CODE>TreeNode#setNodeNumbers()</CODE> method) of the lowest node containing all taxa present in taxaContained, a <CODE>HashSet</CODE> of <CODE>String</CODE>s representing taxa.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashSet&lt;java.lang.String&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getStates()">getStates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.HashMap&lt;java.lang.String,java.util.HashSet&lt;java.lang.String&gt;[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getTipAndMRCAStatesOf(java.util.HashSet)">getTipAndMRCAStatesOf</A></B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;tipsToTrace)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intended to return the tip states and MRCA of all said tips.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getTipNumber(java.lang.String)">getTipNumber</A></B>(java.lang.String&nbsp;taxonName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A method that extracts the ID (numbering) for tip taxonName within the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getTipsBelow()">getTipsBelow</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a list of the taxa (terminal tips) below this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#getTipsInOrder()">getTipsInOrder</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A method that gets the terminal tips labelling, hopefully in left-right post-order traversal ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#howManyFromMonophyleticSet(java.util.HashSet)">howManyFromMonophyleticSet</A></B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;someTaxa)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the size of the largest <i>monophyletic</i> clade for the given taxa list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#howManyTips()">howManyTips</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simple utility method to count tips attached below this node (post-order traversal).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#printRecursively()">printRecursively</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#printRecursivelyAsNumberedNodes()">printRecursivelyAsNumberedNodes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints the recursive (Newick) representation of this node (tree)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#printRecursivelyLabelling(java.lang.String[])">printRecursivelyLabelling</A></B>(java.lang.String[]&nbsp;someTaxa)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#printStates()">printStates</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#printTree()">printTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#resolveFitchStates(java.util.HashSet[])">resolveFitchStates</A></B>(java.util.HashSet&lt;java.lang.String&gt;[]&nbsp;parentStates)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs the pre-order (root-leaves) traversal to set the fitch states, 
 <br/>ASSUMING: 
 
 a pre-order traversal has occured to set the states via <CODE>TreeNode#getFitchStates()</CODE>;</i>
 <i>and</i> any ambiguous states present in the top node have been resolved (randomly) via <A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#resolveFitchStatesTopnode()"><CODE>resolveFitchStatesTopnode()</CODE></A>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#resolveFitchStatesTopnode()">resolveFitchStatesTopnode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs <i>no</i> traversal to set the fitch states, simply randomly picks any of the available states if ambiguous (e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#setContent(java.lang.String)">setContent</A></B>(java.lang.String&nbsp;content)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#setNodeNumbers(int, int)">setNodeNumbers</A></B>(int&nbsp;maxTipNumbering,
               int&nbsp;maxInternalNumbering)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numbering of nodes; tips in order unless tip content is entirely numeric, in which case tips == numbers assumed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#setTipNameNumberMapping(java.util.HashMap)">setTipNameNumberMapping</A></B>(java.util.HashMap&lt;java.lang.String,java.lang.Integer&gt;&nbsp;tipNumberMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the HashMap<String,Integer> that will contain the taxon names / numeric IDs (both unique).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#subtreeContains(java.lang.String[])">subtreeContains</A></B>(java.lang.String[]&nbsp;someTaxa)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override the toString method for nodes.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="states"><!-- --></A><H3>
states</H3>
<PRE>
public java.util.HashSet&lt;java.lang.String&gt;[] <B>states</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="TreeNode(java.lang.String, int)"><!-- --></A><H3>
TreeNode</H3>
<PRE>
public <B>TreeNode</B>(java.lang.String&nbsp;tree,
                int&nbsp;startAt)</PRE>
<DL>
<DD>Constructor for node
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>tree</CODE> - <DD><CODE>startAt</CODE> - </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getEndPos()"><!-- --></A><H3>
getEndPos</H3>
<PRE>
public int <B>getEndPos</B>()</PRE>
<DL>
<DD>Returns the position the last node constructor left at
<P>
<DD><DL>

<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Override the toString method for nodes.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setNodeNumbers(int, int)"><!-- --></A><H3>
setNodeNumbers</H3>
<PRE>
public int[] <B>setNodeNumbers</B>(int&nbsp;maxTipNumbering,
                            int&nbsp;maxInternalNumbering)</PRE>
<DL>
<DD>Numbering of nodes; tips in order unless tip content is entirely numeric, in which case tips == numbers assumed. Internal nodes numbered L-R and root-tip
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>maxTipNumbering</CODE> - tip numbering from 1 on<DD><CODE>maxInternalNumbering</CODE> - number of last assigned tip
<DT><B>Returns:</B><DD>updated last numbering; [tip,internal] (int[])</DL>
</DD>
</DL>
<HR>

<A NAME="getFitchStates(java.util.HashMap)"><!-- --></A><H3>
getFitchStates</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public java.util.HashSet&lt;java.lang.String&gt;[] <B>getFitchStates</B>(java.util.HashMap&lt;java.lang.String,java.util.HashSet&lt;java.lang.String&gt;[]&gt;&nbsp;inputStates)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;
<P>
<DD>Not a very clearly encapsulated method. This call achieves <i>three</i> things:
        <ol>
                <li>Set the states of the terminal taxa by matching the <A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#content"><CODE>content</CODE></A> for any <A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#isTerminal"><CODE>isTerminal</CODE></A> nodes to the corresponding String keyin the inputStates HashMap;</li>
                <li>Set the states of the internal nodes of the tree, using the first pass of the Fitch (1967) algorithm (union or intersection) and the daughter node states</li>
                <li>Return the states of the current node, e.g. the top  (root) node of the tree if this method is called on that node. These may also be ambiguous.</li>
 </ol>
 This calls a post-order (leaves-to-root) traversal of the tree, terminal taxa will have their states determined by the input list.
 <p>Execution:
 <pre>
 if(isTerminal){
        states = inputStates.get(name)
  return states
 }else{
         leftDaughterStates = daughters[0].getFitchStates(inputStates)
        rightDaughterStates = daughters[1].getFitchStates(inputStates)
  for(i, stateslength){
        resolve fitch states; e.g. if no intersection between left & right states, union; else intersection
  }
  return states
 }
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>states;</CODE> - a HashMap of all of the states for terminal taxa
<DT><B>Returns:</B><DD>post-order traversal will give sets of possible states for this node, pass up.</DL>
</DD>
</DL>
<HR>

<A NAME="resolveFitchStatesTopnode()"><!-- --></A><H3>
resolveFitchStatesTopnode</H3>
<PRE>
public void <B>resolveFitchStatesTopnode</B>()</PRE>
<DL>
<DD>Performs <i>no</i> traversal to set the fitch states, simply randomly picks any of the available states if ambiguous (e.g. states[i].size()>1).
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resolveFitchStates(java.util.HashSet[])"><!-- --></A><H3>
resolveFitchStates</H3>
<PRE>
public void <B>resolveFitchStates</B>(java.util.HashSet&lt;java.lang.String&gt;[]&nbsp;parentStates)</PRE>
<DL>
<DD>Performs the pre-order (root-leaves) traversal to set the fitch states, 
 <br/>ASSUMING: 
 <ul>
 <li>a pre-order traversal has occured to set the states via <CODE>TreeNode#getFitchStates()</CODE>;</i>
 <li><i>and</i> any ambiguous states present in the top node have been resolved (randomly) via <A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html#resolveFitchStatesTopnode()"><CODE>resolveFitchStatesTopnode()</CODE></A></li>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printStates()"><!-- --></A><H3>
printStates</H3>
<PRE>
public void <B>printStates</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getContent()"><!-- --></A><H3>
getContent</H3>
<PRE>
public java.lang.String <B>getContent</B>()</PRE>
<DL>
<DD><DL>

<DT><B>Returns:</B><DD>the content</DL>
</DD>
</DL>
<HR>

<A NAME="setContent(java.lang.String)"><!-- --></A><H3>
setContent</H3>
<PRE>
public void <B>setContent</B>(java.lang.String&nbsp;content)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>content</CODE> - the content to set</DL>
</DD>
</DL>
<HR>

<A NAME="getStates()"><!-- --></A><H3>
getStates</H3>
<PRE>
public java.util.HashSet&lt;java.lang.String&gt;[] <B>getStates</B>()</PRE>
<DL>
<DD><DL>

<DT><B>Returns:</B><DD>the states</DL>
</DD>
</DL>
<HR>

<A NAME="printTree()"><!-- --></A><H3>
printTree</H3>
<PRE>
public void <B>printTree</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRecursively()"><!-- --></A><H3>
printRecursively</H3>
<PRE>
public java.lang.String <B>printRecursively</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRecursivelyAsNumberedNodes()"><!-- --></A><H3>
printRecursivelyAsNumberedNodes</H3>
<PRE>
public java.lang.String <B>printRecursivelyAsNumberedNodes</B>()</PRE>
<DL>
<DD>Prints the recursive (Newick) representation of this node (tree)
<P>
<DD><DL>

<DT><B>Returns:</B><DD>String containing nodes below this one</DL>
</DD>
</DL>
<HR>

<A NAME="printRecursivelyLabelling(java.lang.String[])"><!-- --></A><H3>
printRecursivelyLabelling</H3>
<PRE>
public java.lang.String <B>printRecursivelyLabelling</B>(java.lang.String[]&nbsp;someTaxa)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subtreeContains(java.lang.String[])"><!-- --></A><H3>
subtreeContains</H3>
<PRE>
public boolean <B>subtreeContains</B>(java.lang.String[]&nbsp;someTaxa)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTipAndMRCAStatesOf(java.util.HashSet)"><!-- --></A><H3>
getTipAndMRCAStatesOf</H3>
<PRE>
public java.util.HashMap&lt;java.lang.String,java.util.HashSet&lt;java.lang.String&gt;[]&gt; <B>getTipAndMRCAStatesOf</B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;tipsToTrace)</PRE>
<DL>
<DD>Intended to return the tip states and MRCA of all said tips.
 <p>Currently relies on simply stopping and passing ret hashmap when it has size of tipsTotrace.length (+1 for the MRCA)
 <p>Therefore the desired tip list <b>MUST</b> have been pruned by <A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html" title="class in uk.ac.qmul.sbcs.evolution.convergence"><CODE>TreeNode</CODE></A>.areTipsPresent(HashSet<String> echoMap)} first..
 <p>NB also - 'MRCA' is used as a key for the MRCA states, so there <b>Must Not Be Any Tips Labelled 'MRCA'. At. All.</b> (ideally catch or failsafe this)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tipsToTrace</CODE> - - the terminal taxon tips that we want the states + MRCA of.
<DT><B>Returns:</B><DD><CODE>HashMap&lt;String,HashSet&lt;String&gt;[]&gt;</CODE> - the states</DL>
</DD>
</DL>
<HR>

<A NAME="areTipsPresent(java.util.HashSet)"><!-- --></A><H3>
areTipsPresent</H3>
<PRE>
public java.util.HashSet&lt;java.lang.String&gt; <B>areTipsPresent</B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;echoMap)</PRE>
<DL>
<DD>Which of the tips in the supplied list are below this node?
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>echoMap</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="howManyFromMonophyleticSet(java.util.HashSet)"><!-- --></A><H3>
howManyFromMonophyleticSet</H3>
<PRE>
public int <B>howManyFromMonophyleticSet</B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;someTaxa)</PRE>
<DL>
<DD>Returns the size of the largest <i>monophyletic</i> clade for the given taxa list.
 <br/>Hard polytomies (nodes with n>2 daughters) are counted as monophyletic <b>only</b> if all daughters are monophyletic.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>someTaxa</CODE> - - a <CODE>HashSet&lt;String&gt;</CODE> with target taxa to look for monophly of.
<DT><B>Returns:</B><DD>#of terminal taxa below that node which are in a reciprocally monophyletic clade.<DT><B>Since:</B></DT>
  <DD>r194 2013/08/02</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="containsMonophyleticClade(java.util.HashSet)"><!-- --></A><H3>
containsMonophyleticClade</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public boolean <B>containsMonophyleticClade</B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;someTaxa)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;
<P>
<DD>This method attempts to determine whether there are any monophyletic clades present containing the <CODE>HashSet&lt;String&gt;</CODE> of target taxa.
 <p>@Deprecated - this method does <b>not</b> work well if hard polytomies are present (daughters.size()>2); instead use <CODE>uk.ac.qmul.sbcs.evolution.convergence.TreeNode#howManyFromMonophyleticSet()</CODE>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>someTaxa</CODE> - - a <CODE>HashSet&lt;String&gt;</CODE> with target taxa to look for monophly of.
<DT><B>Returns:</B><DD>boolean ifMonophyletic<DT><B>Since:</B></DT>
  <DD>r194 2013/08/02</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="howManyTips()"><!-- --></A><H3>
howManyTips</H3>
<PRE>
public int <B>howManyTips</B>()</PRE>
<DL>
<DD>Simple utility method to count tips attached below this node (post-order traversal).
<P>
<DD><DL>

<DT><B>Returns:</B><DD>int - number of tips below this node.</DL>
</DD>
</DL>
<HR>

<A NAME="getTipsInOrder()"><!-- --></A><H3>
getTipsInOrder</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>getTipsInOrder</B>()</PRE>
<DL>
<DD>A method that gets the terminal tips labelling, hopefully in left-right post-order traversal ordering.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<String> of terminal tips (taxa names) in order</DL>
</DD>
</DL>
<HR>

<A NAME="getTipsBelow()"><!-- --></A><H3>
getTipsBelow</H3>
<PRE>
public java.lang.String[] <B>getTipsBelow</B>()</PRE>
<DL>
<DD>Get a list of the taxa (terminal tips) below this node.
<P>
<DD><DL>

<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="getNodeNumberingIDContainingTaxa(java.util.HashSet)"><!-- --></A><H3>
getNodeNumberingIDContainingTaxa</H3>
<PRE>
public int <B>getNodeNumberingIDContainingTaxa</B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;taxaContained)</PRE>
<DL>
<DD>A method to retrieve the number (node ID, as set in <CODE>TreeNode#setNodeNumbers()</CODE> method) of the lowest node containing all taxa present in taxaContained, a <CODE>HashSet</CODE> of <CODE>String</CODE>s representing taxa. 
 <p>Note that although all taxa <b>must</b> be present (so, this method does not have predictable behaviour in trees where branches have been pruned etc), the most recent clade containing them which will be reported <b>may not actually be <i>strictly</i> monophyletic</b>. That is, other taxa not listed might be present as well: this method <i>only</i> guarantees that the node returned is the lowest containing all members in the target list.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>taxaContained</CODE> - - a <CODE>HashSet</CODE>&lt;String&gt; of taxon names.
<DT><B>Returns:</B><DD>int; ID of the lowest node containing all members of taxaContained; or -1 otherwise.<DT><B>Since:</B></DT>
  <DD>r293 2014/10/10</DD>
<DT><B>See Also:</B><DD><CODE>HashSet</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getBranchNumberingIDContainingTaxa(java.util.HashSet)"><!-- --></A><H3>
getBranchNumberingIDContainingTaxa</H3>
<PRE>
public int[] <B>getBranchNumberingIDContainingTaxa</B>(java.util.HashSet&lt;java.lang.String&gt;&nbsp;taxaContained)</PRE>
<DL>
<DD>A method to retrieve the number (node ID, as set in <CODE>TreeNode#setNodeNumbers()</CODE> method) of the lowest node containing all taxa present in taxaContained, a <CODE>HashSet</CODE> of <CODE>String</CODE>s representing taxa. 
 <p>Note that although all taxa <b>must</b> be present (so, this method does not have predictable behaviour in trees where branches have been pruned etc), the most recent clade containing them which will be reported <b>may not actually be <i>strictly</i> monophyletic</b>. That is, other taxa not listed might be present as well: this method <i>only</i> guarantees that the node returned is the lowest containing all members in the target list.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>taxaContained</CODE> - - a <CODE>HashSet</CODE>&lt;String&gt; of taxon names.
<DT><B>Returns:</B><DD>int[]; {ID of the lowest node containing all members of taxaContained,ID of the node immediately above that}; or -1 otherwise.<DT><B>See Also:</B><DD><CODE>HashSet</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setTipNameNumberMapping(java.util.HashMap)"><!-- --></A><H3>
setTipNameNumberMapping</H3>
<PRE>
public void <B>setTipNameNumberMapping</B>(java.util.HashMap&lt;java.lang.String,java.lang.Integer&gt;&nbsp;tipNumberMap)</PRE>
<DL>
<DD>Sets the HashMap<String,Integer> that will contain the taxon names / numeric IDs (both unique). This information is required to ensure that classes using specific tip-ID mappings can specify them (e.g.  using PAML's tip-numberings, not native sequential numberings.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tipNumberMap</CODE> - a HashMap of String,Integer containing the taxon names / numeric IDs (both unique)</DL>
</DD>
</DL>
<HR>

<A NAME="getTipNumber(java.lang.String)"><!-- --></A><H3>
getTipNumber</H3>
<PRE>
public int <B>getTipNumber</B>(java.lang.String&nbsp;taxonName)</PRE>
<DL>
<DD>A method that extracts the ID (numbering) for tip taxonName within the tree. NB names are matched using String.equals(String) call, so are caSe SeNsITive.
 <p><b>IMPORTANT</b> returns 0 with no error/exception if no matching tip can be found. Be warned!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>taxonName</CODE> - 
<DT><B>Returns:</B><DD>integer unique ID defining the tip which has this taxonName. NB returns 0 if no tip found with no error.</DL>
</DD>
</DL>
<HR>

<A NAME="getBranches()"><!-- --></A><H3>
getBranches</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeBranch.html" title="class in uk.ac.qmul.sbcs.evolution.convergence">TreeBranch</A>&gt; <B>getBranches</B>()</PRE>
<DL>
<DD>Return all the branches in the tree by postorder traversal
<P>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<TreeBranch> of all branches below this one</DL>
</DD>
</DL>
<HR>

<A NAME="getBranchesAsCoOrdinates(int, int, int, int)"><!-- --></A><H3>
getBranchesAsCoOrdinates</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer[]&gt; <B>getBranchesAsCoOrdinates</B>(int&nbsp;startX,
                                                                         int&nbsp;startY,
                                                                         int&nbsp;branchIncrementX,
                                                                         int&nbsp;branchIncrementY)</PRE>
<DL>
<DD>Returns a list of relative X,Y positions for line segments representing branches, to be rendered with a Graphics2D.drawLine(x1,y1,x2,y2) call or similar.
 <br/>Note this method assumes a strictly bifurcating tree, e.g. n=2 daughters for each node exactly.
 <br/>Note also that 'left' and 'right' refer to these two daughters, not left/right orientation on the screen.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>startX</CODE> - - Xposition to start from<DD><CODE>startY</CODE> - - Y pos to start from<DD><CODE>branchIncrementX</CODE> - - how much to increment each branch by (width)<DD><CODE>branchIncrementY</CODE> - - how much to increment each branch by (height)
<DT><B>Returns:</B><DD>- An ArrayList<Integer[]> of branches. Each Integer[4] of the form {x1, y1, x2, y2}. All x will be positive. Those branches 'left' of the root will have -ve x, those right will have +ve.</DL>
</DD>
</DL>
<HR>

<A NAME="getBranchesAsCoordinatesFromTips(int, int)"><!-- --></A><H3>
getBranchesAsCoordinatesFromTips</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer[]&gt; <B>getBranchesAsCoordinatesFromTips</B>(int&nbsp;depth,
                                                                                 int&nbsp;tipNumber)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNodeByNumberingID(int)"><!-- --></A><H3>
getNodeByNumberingID</H3>
<PRE>
public <A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html" title="class in uk.ac.qmul.sbcs.evolution.convergence">TreeNode</A> <B>getNodeByNumberingID</B>(int&nbsp;nodeID)</PRE>
<DL>
<DD>Method to return the node corresponding to a particular node. NO GUARANTEE an ID is unique, or exists.
 <p>Use with caution!!!!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeIDofMRCA</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/TreeNode.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/TreeBranch.html" title="class in uk.ac.qmul.sbcs.evolution.convergence"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../uk/ac/qmul/sbcs/evolution/convergence/VariantSitesUnavailableException.html" title="class in uk.ac.qmul.sbcs.evolution.convergence"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html?uk/ac/qmul/sbcs/evolution/convergence/TreeNode.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="TreeNode.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
